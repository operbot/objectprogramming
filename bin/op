#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=C0115,C0116,C0413,W0212,C0301,W0613,E0611,E0401


"object programming (op)"


__version__ = "110"


## imports


import atexit
import importlib
import importlib.util
import os
import readline
import rlcompleter
import sys
import shutil
import time
import termios
import traceback


sys.path.insert(0, os.getcwd())


from op.evt import Event
from op.hdl import Command, Handler
from op.obj import Wd, cdir, edit, find, keys, last, printable, save, write
from op.obj import fntime
from op.run import Cfg, boot, command, scan, scandir, wait
from op.thr import elapsed, launch
from op.usr import User


## defines


Cfg.name = "op"
Wd.workdir = os.path.expanduser("~/.op")


## classes


class CLI(Handler):

    @staticmethod
    def announce(txt):
        pass

    @staticmethod
    def raw(txt):
        print(txt)
        sys.stdout.flush()


class Console(Handler):

    @staticmethod
    def announce(txt):
        pass

    @staticmethod
    def handle(event):
        Command.handle(event)
        event.wait()

    def poll(self):
        event = Event()
        event.txt = input("> ")
        event.orig = repr(self)
        return event

    @staticmethod
    def raw(txt):
        print(txt)
        sys.stdout.flush()


class Completer(rlcompleter.Completer):

    def __init__(self, options):
        rlcompleter.Completer.__init__(self)
        self.matches = []
        self.options = options

    def complete(self, text, state):
        if state == 0:
            if text:
                self.matches = [
                                s for s in self.options
                                if s and s.startswith(text)
                               ]
            else:
                self.matches = self.options[:]
        try:
            return self.matches[state]
        except IndexError:
            return None


## utilities


def daemon():
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    os.umask(0)
    sis = open("/dev/null", 'r')
    os.dup2(sis.fileno(), sys.stdin.fileno())
    if not Cfg.verbose:
        sos = open("/dev/null", 'a+')
        ses = open("/dev/null", 'a+')
        os.dup2(sos.fileno(), sys.stdout.fileno())
        os.dup2(ses.fileno(), sys.stderr.fileno())


def importer(mname, path=None):
    if path is None:
        spec = importlib.util.find_spec(mname)
    else:
        spec = importlib.util.spec_from_file_location(mname, path)
    if spec:
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)
        return mod
    return None


def initer(mname, path=None):
    mod = importer(mname, path)
    if mod and "init" in dir(mod):
        thr = launch(mod.init)
        thr.join()
    scan(mod)


def scanner(mname, path=None):
    mod = importer(mname, path)
    scan(mod)


def print_exc(ex):
    traceback.print_exception(type(ex), ex, ex.__traceback__)


def setcompleter(optionlist):
    completer = Completer(optionlist)
    readline.set_completer(completer.complete)
    readline.parse_and_bind("tab: complete")
    atexit.register(lambda: readline.set_completer(None))


def wrap(func):
    fds = sys.stdin.fileno()
    gotterm = True
    try:
        old = termios.tcgetattr(fds)
    except termios.error:
        gotterm = False
    try:
        func()
    except (EOFError, KeyboardInterrupt):
        print("")
    finally:
        if gotterm:
            termios.tcsetattr(fds, termios.TCSADRAIN, old)
        for evt in Command.errors:
            print_exc(evt.__exc__)


## commands


def cfg(event):
    last(Cfg)
    if not event.sets:
        event.reply(printable(
                              Cfg,
                              keys(Cfg),
                              skip="name,password,prs",
                             )
                   )
    else:
        edit(Cfg, event.sets)
        write(Cfg)
        event.done()


def cmds(event):
    event.reply(",".join(Command.cmd))


def dlt(event):
    if not event.args:
        event.reply("dlt <username>")
        return
    selector = {"user": event.args[0]}
    for obj in find("user", selector):
        obj.__deleted__ = True
        save(obj)
        event.done()
        break


def dis(event):
    if not event.args:
        event.reply("disable <modname>")
        return
    name = event.args[0]
    if name == "disable":
        event.reply("i won't disable myself")
        return
    name += ".py"
    path = os.path.join(Wd.moddir(), name)
    if not os.path.exists(path):
        event.reply("can't find %s to disable" % name)
        return
    nmd = os.path.join(Wd.get(), "notmod")
    cdir(nmd)
    dest = os.path.join(nmd, name)
    shutil.move(path, dest)
    event.ok()


def ena(event):
    if not event.args:
        event.reply("enable <modname>")
        return
    name = event.args[0]
    if name == "enable":
        event.reply("i won't enable myself")
        return
    name += ".py"
    path = os.path.join(Wd.get(), "notmod", name)
    if not os.path.exists(path):
        event.reply("missing %s" % name)
        return
    dest = os.path.join(Wd.moddir(), name)
    shutil.move(path, dest)
    event.ok()


def met(event):
    if not event.rest:
        nmr = 0
        for obj in find("user"):
            event.reply("%s %s %s %s" % (
                                         nmr,
                                         obj.user,
                                         obj.perms,
                                         elapsed(time.time() - fntime(obj.__fnm__)))
                                        )
            nmr += 1
        return
    user = User()
    user.user = event.rest
    user.perms = ["USER"]
    save(user)
    event.done()


def mods(event):
    modstr = ",".join([x[:-3] for x in os.listdir(Wd.moddir()) if not x.startswith("_")])
    notmodstr = ",".join([x[:-3] for x in os.listdir(Wd.nmdir()) if not x.startswith("_")])
    event.reply("enabled: %s disabled: %s" % (modstr, notmodstr))


def opr(event):
    if not event.rest:
        nmr = 0
        for obj in find("user"):
            event.reply("%s %s %s %s" % (
                                         nmr,
                                         obj.user,
                                         obj.perms,
                                         elapsed(time.time() - fntime(obj.__fnm__)))
                                        )
            nmr += 1
        return
    user = user.match("mod.irc.User", {"user": event.rest})
    if not user:
        user = User()
    user.user = event.rest
    if "OPER" not in user.perms:
        user.perms.append("OPER")
    write(user)
    event.done()


def pop(event):
    if not os.path.exists("mod"):
        event.reply("no mod dir to populate from")
        return
    destdir = os.path.join(Wd.get(), "notmod", "")
    cdir(destdir)
    dirs = ["mod", "notmod"]
    for dname in dirs:
        for name in os.listdir(dname):
            if not name.endswith(".py"):
                continue
            path = os.path.join(dname, name)
            dest = os.path.join(destdir, name)
            event.reply("%s -> %s" % (path, dest))
            shutil.copy(path, dest)
    event.ok()


def ver(event):
    event.reply("OP version %s" % __version__)


## runtime


def main():
    boot()
    Command.add(cmds)
    Command.add(ver)
    scandir(Wd.moddir(), scanner, "mod")
    if Cfg.prs.txt:
        Command.add(cfg)
        Command.add(dlt)
        Command.add(dis)
        Command.add(ena)
        Command.add(met)
        Command.add(mods)
        Command.add(opr)
        Command.add(pop)
        cli = CLI()
        return command(cli, Cfg.prs.otxt)
    if Cfg.daemon:
        daemon()
        Cfg.wait = True
    scandir(Wd.moddir(), initer, "mod")
    if Cfg.console:
        setcompleter(Command.cmd)
        date = time.ctime(time.time()).replace("  ", " ")
        print("%s started at %s %s" % (Cfg.name.upper(), date, printable(Cfg, skip="name", plain=True)))
        cli = Console()
        cli.start()
        Cfg.wait = True
    if Cfg.wait:
        wait()


wrap(main)
